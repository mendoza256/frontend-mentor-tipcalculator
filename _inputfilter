let lastValidInputValue;
let selectedDot = false;

// Triggers whenever a printable character is pressed
// **shortcuts using printable characters also triggers this, but backspace ans delete wont, for example.
const onKeypress = (e) => {
  // prevent "." if the target value IS ALREADY A DECIMAL NUMBER and the dot of the value is not selected
  // unfortunately, it will only be triggered if the value has a decimal
  // meaning that a field displaying "13." has a value of "13"
  // but a field displaying "13.1" has a value of "13.1"
  // so unless there's a number after the period in the field, the target's value will not have an index of "."
  if (e.key === "." && e.target.value.indexOf(".") !== -1 && !selectedDot) e.preventDefault();
  selectedDot = false;

  //prevent the e symbol in the field, because we expect humans to fill this, no javascript formated numbers for this field
  if (e.key === "e") e.preventDefault();

// Triggers whenever a change is applied to the input
// behaves similarly to onkeyup, but is more responsibe to fast typing
// with onkeyup if you press down "1" "2" and  "3" and get to "3" before releasing "1", keyup triggers after the release
// with oninput, it triggers as soon as an event changes the input value, even if the key is not released
// this means e.preventDefault(); has no effect here, this happens after the default happened.
const onInput = (e) => {
  // If a decimal is placed before mode than 2 numbers as in:
  // input value before change was : "123456"
  // user inserted "." between 3 and 4
  // input value is now "123.456"
  // input value exceeds the number of floats.
  if (
    e.target.value.indexOf(".") < e.target.value.length - e.target.getAttribute("data-toFixed") - 1 &&
    e.target.value.indexOf(".") !== -1
  ) {
    let newValue;
    // slice the resulting value to keep only the decimal depth allowed after the first "." found in the value
    newValue = e.target.value.slice(
      0,
      e.target.value.indexOf(".") +
        parseInt(e.target.getAttribute("data-toFixed")) +
        1
    );
    // turn sliced string to number and assign it to field value
    newValue = parseFloat(newValue);
    e.target.value = newValue;
  }
  // A number field value will return "" if eighter it is empty, or if its value is an invalid number
  // and since "13.1." is an invalid number, it will return ""
  // so if someone tries to type an invalid number in the field, we go back, 
  // without the use of e.preventDefault(); since it already happened
  // Sadly this means that if you get at the end of you input and press "." repeatedly
  // the dot appears and disapears because but "13." will return "13" but "13.." will return ""
  // so this will replace "13.." with "13"
  if (e.target.value !== "") {
    // take a snapshot of the value if it is not empty
    lastValidInputValue = e.target.value;
  } else if (e.inputType.match(/delete/g)) {
    // take a snapshot of the value if it is empty because the event that triggered this function was caused by a delete action (backspace, delete key, cut)
    lastValidInputValue = "";
  } else {
    // otherwise, this value should go back to the last valid input number saved.
    e.target.value = lastValidInputValue;
  }
};

// if the dot in the field is selected, allow to type a new dot
 const onSelect = (e) => {
   if(window.getSelection().toString().indexOf(".") > -1) selectedDot = true;
 }